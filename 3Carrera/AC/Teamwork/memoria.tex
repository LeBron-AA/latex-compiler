\documentclass[11pt,a4paper]{article}

\usepackage[spanish]{babel}
\usepackage{amsmath,amsfonts, amssymb, amsthm}
\usepackage{graphicx, tikz, xparse, array}
\usepackage[top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[colorlinks=true]{hyperref}
\usepackage{setspace}
\usepackage{caption}
\usepackage[x11names]{xcolor}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage[most]{tcolorbox}

\tcbuselibrary{breakable}


%Colores
\definecolor{verdeSuave}{HTML}{6AD58A}
\definecolor{verdeFuerte}{HTML}{206936}
\definecolor{blanco}{HTML}{FFFFFF}
\definecolor{negro}{HTML}{000000}
\definecolor{azulSuave}{HTML}{6ac9d5}
\definecolor{naranjaSuave}{HTML}{d5c06a}
\definecolor{rojoSuave}{HTML}{EF4949}
\definecolor{amarilloSuave}{HTML}{D8E058}


\setstretch{1.2}
\decimalpoint

\begin{document}
  
\begin{titlepage}
  \centering  
  \vspace*{1cm}  % Espacio opcional antes de la imagen
  \includegraphics[width=0.3\textwidth]{uniovi.jpg} \hspace{2cm}
  \includegraphics[width=0.3\textwidth]{descarga.jpeg} \\[1cm] 
  \vspace{\fill}% Imagen centrada arriba
  \hrule
  \vspace{0.5cm}
  {\Huge \bfseries Arquitectura de Computadores\par}
  \vspace{0.5cm}
  {\Large \bfseries Trabajo en grupo\par}
  \vspace{0.5cm}

  \hrule
  \vspace{1cm}
  {\bfseries PL1-A \\ [4ex]
  Jorge Gota Ortín UO301023\\[3ex]
  Javier Ortín Rodenas UO299855\\[3ex]
  Andrés Fernández-Junquera Fernández UO302086\\[3ex]
  Alejandro Jarillo Pineda UO302394\par} % Nombres centrados  
  \vspace{\fill}  % Espacio después de los nombres

\end{titlepage}



\newpage

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=DeepSkyBlue3}

\newpage
\section{Algoritmo a aplicar a la imagen}
\subsection{Algoritmo matemático}
\label{result:1.1}
\hspace{3mm} En nuestro caso, el algoritmo a implementar es el número 3. Tiene como entrada una única imagen y genera como salida una versión de la misma en blanco y negro. Sean $(R,G,B)$ las componentes de un píxel de la entrada, las componentes $(R',G',B')$ del píxel equivalente en la imagen de salida vienen dadas por:
\begin{flalign*}
    R' = G' = B' = 255 - (0.3 \cdot R + 0.59 \cdot G + 0.11 \cdot B)
\end{flalign*}
Se pasa a escala de grises con la siguiente media ponderada:
$$L = 0.3 \cdot R + 0.59 \cdot G + 0.11 \cdot B$$
A continuación, se invierte al hacer $R' = G' = B' = 255 - L$, de ahí el nombre de ``inversión en blanco y negro''.
\vspace{2mm}  \newline Matemáticamente, los valores de la imagen destino deberían estar comprendidos siempre entre $0$ y $255$. Debido a la sencillez de este algoritmo, no será sencillo saturar, pues el resultado de las operaciones tendrá un valor adecuado siempre.

\vspace{8mm}  
\subsection{Funcionamiento general e implementación monohilo}
Comencemos analizando la función \texttt{main} y el funcionamiento general del programa:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/monohilo/main.png}
\end{figure}
\noindent El funcionamiento general del programa es el mismo para las tres implementaciones:

\vspace{2mm} En primer lugar, cargamos la imagen teniendo en cuenta la posibilidad de que esta pueda no existir y manejando el error en tal caso. A continuación, iniciamos las variables necesarias, deteniendo la ejecución si no fuese posible asignar memoria adecuadamente. Una vez hecho esto, medimos el tiempo que tarda en ejecutarse el algoritmo 100 veces (para que tarde el tiempo mínimo deseado), manejando los errores de cronometrado en caso de haberlos. Finalmente, se muestra el tiempo transcurrido así como la imagen destino.

\vspace{4mm} \noindent Veamos ahora cómo se estructura el algoritmo del filtro:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/monohilo/filter.png}
\end{figure}

El algoritmo recorre los píxeles de la imagen, aplicando para cada uno de ellos el \hyperref[result:1.1]{algoritmo matemático} visto. 

\vspace{8mm}
\subsubsection{Implementación multihilo}
\hspace{3mm} El funcionamiento general del programa es el mismo. Por tanto, nos centraremos únicamente en las modificaciones necesarias para implementar la funcionalidad multihilo.
\vspace{2mm} \newline \indent En esta versión, se asignará un \texttt{filter\_args\_t} a cada hilo para que itere sobre los píxeles que le sean asignados. Por tanto, hemos modificado el \texttt{struct} para que almacene también los píxeles inicial y final que ha de recorrer:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/multihilo/struct.png}
\end{figure}
\vspace{2mm} Veamos cómo se distribuye el trabajo entre los hilos:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/multihilo/distribution.png}
\end{figure}
\indent El parámetro \texttt{shared\_args} contiene la información común a todos los hilos, que ha sido agrupada en forma de \texttt{filter\_args\_t} para facilitar su manejo. A partir de él se inician los campos del resto de \texttt{structs} de este tipo.
\vspace{2mm} \newline \indent Más aún, en este bucle se asignan los píxeles de inicio y final. Para ello, se calculan primero los píxeles base (\texttt{baseWorkPerThread}) de cada hilo, a los que se puede sumar un píxel extra en función del resto de la división. De este modo, nos aseguramos de que se procesen todos los píxeles de la imagen aunque el número total de ellos no sea múltiplo del número de hilos. Además, este sistema distribuye la carga de manera uniforme entre los hilos, en lugar de asignar todos los píxeles restantes (\texttt{remaining}) a un solo hilo.
\end{document}
