\documentclass[11pt,a4paper]{article}

\usepackage[spanish]{babel}
\usepackage{amsmath,amsfonts, amssymb, amsthm}
\usepackage{graphicx, tikz, xparse, array}
\usepackage[top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[colorlinks=true]{hyperref}
\usepackage{setspace}
\usepackage{caption}
\usepackage[x11names]{xcolor}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage[most]{tcolorbox}

\tcbuselibrary{breakable}


%Colores
\definecolor{verdeSuave}{HTML}{6AD58A}
\definecolor{verdeFuerte}{HTML}{206936}
\definecolor{blanco}{HTML}{FFFFFF}
\definecolor{negro}{HTML}{000000}
\definecolor{azulSuave}{HTML}{6ac9d5}
\definecolor{naranjaSuave}{HTML}{d5c06a}
\definecolor{rojoSuave}{HTML}{EF4949}
\definecolor{amarilloSuave}{HTML}{D8E058}


\setstretch{1.2}
\decimalpoint

\begin{document}
  
\begin{titlepage}
  \centering  
  \vspace*{1cm}  % Espacio opcional antes de la imagen
  \includegraphics[width=0.3\textwidth]{uniovi.jpg} \hspace{2cm}
  \includegraphics[width=0.3\textwidth]{descarga.jpeg} \\[1cm] 
  \vspace{\fill}% Imagen centrada arriba
  \hrule
  \vspace{0.5cm}
  {\Huge \bfseries Arquitectura de Computadores\par}
  \vspace{0.5cm}
  {\Large \bfseries Trabajo en grupo\par}
  \vspace{0.5cm}

  \hrule
  \vspace{1cm}
  {\bfseries PL1-A \\ [4ex]
  Jorge Gota Ortín UO301023\\[3ex]
  Javier Ortín Rodenas UO299855\\[3ex]
  Andrés Fernández-Junquera Fernández UO302086\\[3ex]
  Alejandro Jarillo Pineda UO302394\par} % Nombres centrados  
  \vspace{\fill}  % Espacio después de los nombres

\end{titlepage}



\newpage

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=DeepSkyBlue3}

\newpage
\section{Algoritmo a aplicar a la imagen}
\subsection{Algoritmo matemático}
\label{result:1.1}
\hspace{3mm} En nuestro caso, el algoritmo a implementar es el número 3. Tiene como entrada una única imagen y genera como salida una versión de la misma en blanco y negro. Sean $(R,G,B)$ las componentes de un píxel de la entrada, las componentes $(R',G',B')$ del píxel equivalente en la imagen de salida vienen dadas por:
\begin{flalign*}
    R' = G' = B' = 255 - (0.3 \cdot R + 0.59 \cdot G + 0.11 \cdot B)
\end{flalign*}
Se pasa a escala de grises con la siguiente media ponderada:
$$L = 0.3 \cdot R + 0.59 \cdot G + 0.11 \cdot B$$
A continuación, se invierte al hacer $R' = G' = B' = 255 - L$, de ahí el nombre de ``inversión en blanco y negro''.
\vspace{2mm}  \newline Matemáticamente, los valores de la imagen destino deberían estar comprendidos siempre entre $0$ y $255$. Debido a la sencillez de este algoritmo, no será sencillo saturar, pues el resultado de las operaciones tendrá un valor adecuado siempre.

\vspace{8mm}  
\subsection{Funcionamiento general e implementación monohilo}
Comencemos analizando la función \texttt{main} y el funcionamiento general del programa:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/monohilo/main.png}
\end{figure}
\noindent El funcionamiento general del programa es el mismo para las tres implementaciones:

\vspace{2mm} En primer lugar, cargamos la imagen teniendo en cuenta la posibilidad de que esta pueda no existir y manejando el error en tal caso. A continuación, iniciamos las variables necesarias, deteniendo la ejecución si no fuese posible asignar memoria adecuadamente. Una vez hecho esto, medimos el tiempo que tarda en ejecutarse el algoritmo 100 veces (para que tarde el tiempo mínimo deseado), manejando los errores de cronometrado en caso de haberlos. Finalmente, se muestra el tiempo transcurrido así como la imagen destino.

\vspace{4mm} \noindent Veamos ahora cómo se estructura el algoritmo del filtro:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{media/algoritmos/monohilo/filter.png}
\end{figure}

El algoritmo recorre los píxeles de la imagen, aplicando para cada uno de ellos el \hyperref[result:1.1]{algoritmo matemático} visto. 
\end{document}
